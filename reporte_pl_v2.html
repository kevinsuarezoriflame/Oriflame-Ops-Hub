<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore, doc, onSnapshot, setDoc, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDdXF24bG8QL22a8lkHeHd4ToNq5qDdAI4",
    authDomain: "oriflame-ops-hub.firebaseapp.com",
    projectId: "oriflame-ops-hub",
    storageBucket: "oriflame-ops-hub.firebasestorage.app",
    messagingSenderId: "1052710112933",
    appId: "1:1052710112933:web:ed342948f4fb5eb21f074c"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const hojaRef   = doc(db, "appState", "hoja");
  const textosRef = doc(db, "appState", "hoja_texts");

  const CLIENT_ID = (() => {
    try {
      const k = "opsHubClientId";
      const existing = localStorage.getItem(k);
      if (existing) return existing;
      const gen = "c_" + Math.random().toString(16).slice(2) + "_" + Date.now();
      localStorage.setItem(k, gen);
      return gen;
    } catch {
      return "c_" + Math.random().toString(16).slice(2) + "_" + Date.now();
    }
  })();

  // ---------- UI Badge ----------
  function setSyncBadge(msg, ok=true){
    const el=document.getElementById("syncBadge");
    if(!el) return;
    el.textContent = msg;
    el.style.background = ok ? "#d1e7dd" : "#f8d7da";
    el.style.borderColor = ok ? "#badbcc" : "#f5c2c7";
    el.style.color = ok ? "#0f5132" : "#842029";
  }

  // ---------- Hard focus locks (clave para que NO “retroceda”) ----------
  const lock = { pl:false, res:false, bulk:false, qty:false };

  function bindFocusLocks(){
    const pl = document.getElementById("plInput");
    const res = document.getElementById("resInput");
    const bulk = document.getElementById("bulkInput");

    [ [pl,"pl"], [res,"res"], [bulk,"bulk"] ].forEach(([el,key])=>{
      if(!el) return;
      el.addEventListener("focus", ()=>{ lock[key]=true; });
      el.addEventListener("blur",  ()=>{ lock[key]=false; applyPendingIfSafe(); });
    });

    // qty dinámicos: si estás en cualquier input qty, bloquea
    document.addEventListener("focusin", (ev)=>{
      const t = ev.target;
      if (t && t.matches && t.matches('input[data-role="qty"]')) lock.qty = true;
    });
    document.addEventListener("focusout", (ev)=>{
      const t = ev.target;
      if (t && t.matches && t.matches('input[data-role="qty"]')) {
        lock.qty = false;
        setTimeout(applyPendingIfSafe, 30);
      }
    });
  }

  function isEditingAnyText(){
    return lock.pl || lock.res || lock.bulk;
  }
  function isEditingQty(){
    return lock.qty;
  }

  // ---------- Safe map serialization ----------
  function snapshotToPlainObjectMap(m) {
    const obj = {};
    for (const [k,v] of m.entries()) obj[k] = v;
    return obj;
  }
  function objectToMap(obj) {
    const m = new Map();
    if (!obj || typeof obj !== "object") return m;
    for (const k of Object.keys(obj)) {
      const n = parseInt(obj[k], 10);
      if (Number.isFinite(n) && n > 0) m.set(k, n);
    }
    return m;
  }

  // ---------- State ----------
  let isApplyingRemote = false;

  // Control de eco local
  let lastLocalWriteTexts = 0;
  let lastLocalWriteState = 0;

  // Control de “último aplicado remoto” (evita re-aplicar y mover cursor)
  let lastAppliedTextsUpdate = 0;
  let lastAppliedStateUpdate = 0;

  let saveTimer = null;
  let pendingRemoteTexts = null;
  let pendingRemoteState = null;

  function getTextsPayload() {
    return {
      version: 4,
      clientId: CLIENT_ID,
      clientUpdatedAt: Date.now(),
      plText: document.getElementById("plInput")?.value || "",
      resText: document.getElementById("resInput")?.value || "",
      bulkText: document.getElementById("bulkInput")?.value || ""
    };
  }

  function getStatePayload() {
    return {
      version: 4,
      clientId: CLIENT_ID,
      clientUpdatedAt: Date.now(),
      qtyById: snapshotToPlainObjectMap(STATE.qtyById),
      batchesByPanel: STATE.batchesByPanel || {p1:[],p2:[],p3:[]},
      selectedBatchIdByPanel: STATE.selectedBatchIdByPanel || {p1:null,p2:null,p3:null}
    };
  }

  function scheduleSave(){
    if (isApplyingRemote) return;
    setSyncBadge("Sync: guardando…");
    clearTimeout(saveTimer);

    saveTimer = setTimeout(async ()=>{
      try{
        const textsPayload = getTextsPayload();
        const statePayload = getStatePayload();

        lastLocalWriteTexts = textsPayload.clientUpdatedAt;
        lastLocalWriteState = statePayload.clientUpdatedAt;

        await Promise.all([
          setDoc(textosRef, { ...textsPayload, updatedAt: serverTimestamp() }, { merge:true }),
          setDoc(hojaRef,   { ...statePayload, updatedAt: serverTimestamp() }, { merge:true })
        ]);

        setSyncBadge("Sync: OK (guardado)", true);
      }catch(e){
        console.warn("No se pudo guardar:", e);
        setSyncBadge("Sync: ERROR (ver consola)", false);
      }
    }, 500);
  }

  function applyPendingIfSafe(){
    if (isApplyingRemote) return;

    // Si está editando texto, NO tocar textos
    if (!isEditingAnyText() && pendingRemoteTexts){
      const data = pendingRemoteTexts;
      pendingRemoteTexts = null;

      // Evitar re-aplicar viejo
      if ((data.clientUpdatedAt||0) <= lastAppliedTextsUpdate) return;

      isApplyingRemote = true;
      if (typeof data.plText === "string")  document.getElementById("plInput").value  = data.plText;
      if (typeof data.resText === "string") document.getElementById("resInput").value = data.resText;
      if (typeof data.bulkText === "string")document.getElementById("bulkInput").value= data.bulkText;
      lastAppliedTextsUpdate = data.clientUpdatedAt || Date.now();
      isApplyingRemote = false;

      setSyncBadge("Sync: OK (texto remoto aplicado) — presiona Procesar", true);
    }

    // Si está digitando qty, NO tocar estado
    if (!isEditingQty() && pendingRemoteState){
      const data = pendingRemoteState;
      pendingRemoteState = null;

      if ((data.clientUpdatedAt||0) <= lastAppliedStateUpdate) return;

      isApplyingRemote = true;
      STATE.qtyById = objectToMap(data.qtyById);
      if (data.batchesByPanel) STATE.batchesByPanel = data.batchesByPanel;
      if (data.selectedBatchIdByPanel) STATE.selectedBatchIdByPanel = data.selectedBatchIdByPanel;
      refreshAllTables();
      lastAppliedStateUpdate = data.clientUpdatedAt || Date.now();
      isApplyingRemote = false;

      setSyncBadge("Sync: OK (estado remoto aplicado)", true);
    }
  }

  // ---------- Snapshot: Textos ----------
  onSnapshot(textosRef, (snap)=>{
    if (!snap.exists()) return;
    const data = snap.data() || {};
    const t = data.clientUpdatedAt || 0;

    // 1) No re-aplicar viejo
    if (t <= lastAppliedTextsUpdate) return;

    // 2) Ignorar eco de mi propia escritura
    if (data.clientId === CLIENT_ID && t === lastLocalWriteTexts) return;

    // 3) Si estoy editando, NO aplicar (para que no “retroceda”)
    if (isEditingAnyText()){
      pendingRemoteTexts = data;
      setSyncBadge("Sync: remoto en cola (estás escribiendo)", false);
      return;
    }

    isApplyingRemote = true;
    if (typeof data.plText === "string")  document.getElementById("plInput").value  = data.plText;
    if (typeof data.resText === "string") document.getElementById("resInput").value = data.resText;
    if (typeof data.bulkText === "string")document.getElementById("bulkInput").value= data.bulkText;
    lastAppliedTextsUpdate = t;
    isApplyingRemote = false;

    setSyncBadge("Sync: OK (texto cargado) — presiona Procesar", true);
  });

  // ---------- Snapshot: Estado ----------
  onSnapshot(hojaRef, (snap)=>{
    if (!snap.exists()) return;
    const data = snap.data() || {};
    const t = data.clientUpdatedAt || 0;

    if (t <= lastAppliedStateUpdate) return;
    if (data.clientId === CLIENT_ID && t === lastLocalWriteState) return;

    if (isEditingQty()){
      pendingRemoteState = data;
      setSyncBadge("Sync: estado en cola (digitando qty)", false);
      return;
    }

    isApplyingRemote = true;
    STATE.qtyById = objectToMap(data.qtyById);
    if (data.batchesByPanel) STATE.batchesByPanel = data.batchesByPanel;
    if (data.selectedBatchIdByPanel) STATE.selectedBatchIdByPanel = data.selectedBatchIdByPanel;
    refreshAllTables();
    lastAppliedStateUpdate = t;
    isApplyingRemote = false;

    setSyncBadge("Sync: OK (estado cargado)", true);
  });

  // ---------- Limpiar hoja (global) ----------
  window.limpiarHoja = async function(){
    if (!confirm("¿Seguro que deseas limpiar la hoja? Esto se borrará para TODOS.")) return;

    const now = Date.now();
    lastLocalWriteTexts = now;
    lastLocalWriteState = now;
    lastAppliedTextsUpdate = now;
    lastAppliedStateUpdate = now;

    const statePayload = {
      version: 4, clientId: CLIENT_ID, clientUpdatedAt: now,
      qtyById: {}, batchesByPanel:{p1:[],p2:[],p3:[]}, selectedBatchIdByPanel:{p1:null,p2:null,p3:null},
      updatedAt: serverTimestamp()
    };
    const textsPayload = {
      version: 4, clientId: CLIENT_ID, clientUpdatedAt: now,
      plText:"", resText:"", bulkText:"",
      updatedAt: serverTimestamp()
    };

    try{
      await Promise.all([
        setDoc(hojaRef, statePayload, {merge:true}),
        setDoc(textosRef, textsPayload, {merge:true})
      ]);
    }catch(e){
      console.warn("No se pudo limpiar:", e);
    }

    // aplicar local
    isApplyingRemote = true;
    document.getElementById("plInput").value="";
    document.getElementById("resInput").value="";
    document.getElementById("bulkInput").value="";

    STATE.p1=[]; STATE.p2=[]; STATE.p3=[];
    STATE.qtyById = new Map();
    STATE.batchesByPanel={p1:[],p2:[],p3:[]};
    STATE.selectedBatchIdByPanel={p1:null,p2:null,p3:null};
    STATE.moveById = new Map();

    refreshAllTables();
    isApplyingRemote = false;

    setSyncBadge("Sync: OK (limpieza aplicada)", true);
  };

  // ---------- Hooks ----------
  bindFocusLocks();

  ["plInput","resInput","bulkInput"].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("input", scheduleSave);
  });

  document.addEventListener("input",(ev)=>{
    const t = ev.target;
    if (t && t.matches && t.matches('input[data-role="qty"]')) scheduleSave();
  });

  document.getElementById("process")?.addEventListener("click", ()=>{
    setTimeout(scheduleSave, 100);
  });

  setSyncBadge("Sync: listo", true);
</script>
